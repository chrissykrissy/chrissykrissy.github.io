---
title : "[멀티스레딩 리뷰 중]체크/언체크 예외"
date: 2024-09-26 +1300
categories: [Java]
tags: [exception]
---
> ```Runnable``` 인터페이스의 ```run()``` 메서드를 구현할 때 InterruptedException 체크 예외를 밖으로 던질 수 없는 이유를 알아보면서 체크/언체크 예외에 대해 복습하기로 하였다. 

![exception](/assets/img/multithreading/exception.png)

**Throwable** : 최상위 예외 객체이다. ```Exception```과 ```Error``` 가 있고 크게 체크와 언체크 예외로 분류할 수 있다. 

**Exception** : 애플리케이션 로직에서 다룰 수 있는 실질적인 최상위 예외이다. 컴파일 단계에서 체크하기 때문에 체크 예외라고 한다. 단, ```RuntimeException```은 ```Exception```의 하위 예외 객체이지만 언체크 예외이다. 

**Error** : 메모리 부족이나 심각한 시스템 오류와 같이 애플리케이션에서 복구 불가능한 시스템 예외이다(언체크). 개발자는 이 예외를 잡으려고 하면 안된다. 

### 예외 처리의 기본 규칙
1. 예외는 잡아서 처리하거나 외부로 던질 수 있다.
2. 예외를 처리할 때 지정한 예외는 그 하위 예외까지 모두 포함된다.
   1. Exception 을 catch 로 잡으면 그 하위 예외들도 모두 잡을 수 있다.
   2. Exception 을 throws 로 던지면 그 하위 예외들도 모두 던질 수 있다.

## 체크예외 vs. 언체크 예외
> **체크예외** : 개발자는 예외를 잡아서 처리하거나 던져야 한다.<br>
> **언체크 예외** : 개발자가 예외 처리를 하지 않아도 된다. 

### 선택원칙
1. 기본적으로 런타임 예외를 사용하자
2. 체크 예외는 비즈니스 로직상 의도적으로 던지는 예외에만 사용하자

>```따라서, 체크 예외를 run() 메서드에서 던질 수 없도록 강제함으로써, 개발자는 반드시 try-catch 블록을 사용하여 처리하게 된다. 이는 예외 발생시 예외가 적절히 처리되지 않아서 프로그램이 비정상 종료되는 상황을 방지할 수 있다.``` <br>
- 특히 멀티스레딩 환경에서는 예외 처리를 강제함으로써 스레드의 안정성과 일관성을 유지 할 수 있다. 


참조 : https://velog.io/@dondonee/Java-%EC%B2%B4%ED%81%AC-%EC%98%88%EC%99%B8-vs-%EC%96%B8%EC%B2%B4%ED%81%AC-%EC%98%88%EC%99%B8 