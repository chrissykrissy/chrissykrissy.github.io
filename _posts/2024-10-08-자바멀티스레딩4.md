---
title : 스레드 제어와 생명 주기2
date: 2024-10-08 +2100
categories: [Java]
tags: [multithreading]
---
## 인터럽트 (Interrupt)
특정 스레드의 작업을 중간에 중단하려면 어떻게 해야할까?
- 변수사용
  - 문제 : ```runFlag=false```를 통해 작업 중단을 지시해도, work 스레드가 즉각 반응하지 않는다. 이는, ```sleep(3000)```을 통해 3초간 자고 꺤 뒤 ```while(runFlag)``` 를 체크하기 때문.

### 어떻게 하면 ```sleep()```처럼 스레드가 대기하는 상태에서 스레드를 깨우고, 작업도 빨리 종료 할 수 있을까?
> 인터럽트를 사용하면, ```WAITING```, ```TIMED_WAITING``` 같은 대기 상태의 스레드를 직접 깨워서 작동하는 ```RUNNABLE``` 상태로 만들 수 있다. 

- 특정 스레드의 인스턴스에 ```interrupt()``` 메서드를 호출하면, 해당 스레드에 인터럽트가 발생한다.
- 인터럽트가 발생하면 해당 스레드에 ```InterruptedException```이 발생한다. 
- 이때, 인터럽트를 받은 스레드는 대기상태에서 깨어나 ```RUNNABLE``` 상태가 되고, 코드를 정상 수행한다. 
    - 이때, ```InterruptedException```을 ```catch```로 받아서 정상 흐름으로 변경하면 된다. 
    - (Runnable 상태여야 catch의 예외 코드도 실행될 수 있다.)
- 참고로, 인터럽트를 호출했다고 즉각 ```InterruptedException```이 발생하는 것이 아니라, ```sleep()``` 처럼 ```InterruptedException```을 던지는 메서드를 호출 하거나 호출 중일 때 예외가 발생한다. 
  - 따라서, ```while(true)``` 부분은 체크를 하지 않는다..!
- 위 부분은 ```while(인터럽트_상태_확인)```으로 바꾸면 더 빠르게 while 문을 빠져나갈 수 있다.
- **!주의!** ```isInterrupted()```는 상태변경을 하지 않기 때문에 인터럽트가 발생하는 ```sleep()```같은 코드가 이후에 있으면 해당 코드에서 인터럽트 예외가 발생하게 된다. 
  - ex) 자원정리를 하는 도중에 인터럽트가 발생하여 자원정리에 실패
- 따라서, 인터럽트의 목적을 달성하면 인터럽트 상태를 다시 정상으로 돌려두어야 함.

```Thread.interrupted()```
> 호출 했을때, 스레드가 인터럽트상태(true)라면 true를 반환하고, 해당 스레드의 인터럽트 상태를 false 로 변경한다.

```volatile```
> 여러 스레드가 동시에 접근하는 변수에는 이 키워드를 붙여주어야 안전하다.

```ConcurrentLinkedQueue```
> 여러 스레드가 동시에 접근하는 경우, 컬렉션 프레임워크가 제공하는 일반적인 자료구조를 사용하면 안전하지 않다. 동시성을 지원하는 동시성 컬렉션을 사용해야한다. 

## 양보하기 (Yield)
**vs. sleep**
- ```sleep(1)``` 을 사용해서 스레드의 상태를 1ms 아주 잠깐 ```RUNNABLE``` -> ```TIMED_WAITING``` 으로 변경한다.
  - CPU자원을 사용하지 않고, 실행 스케줄링에서 잠시 제외된다. 
  - 대기 이후 다시 ```TIMED_WAITING``` -> ```RUNNABLE```이 되면서 실행 스케줄링에 포함된다.
  - 결과적으로 ```TIMED_WAITING``` 상태가 되면서 다른 스레드에 실행을 양보하게 된다. 
> ```RUNNABLE``` -> ```TIMED_WAITING``` -> ```RUNNABLE``` 로 변경되는 복잡한 과정을 거치고, 또, 특정 시간만큼 스레드가 실행되지 않는 단점이 있다. 

**yield()의 작동**
- 자바의 스레드가 ```RUNNABLE``` 상태일때, 운영체제의 스케줄링은 ```Running```, 혹은 ```ready``` 의 상태를 가질 수 있다.
  - 운영체제는 실행 상태의 스레드들을 잠깐만 실행하고 실행 대기 상태로 만든다. 또 실행 대기 상태의 스레드들을 잠깐만 실행 상태로 변경해서 실행한다. 자바에선 구분 불가능. 
- ```Thread.yield()``` 메서드는 현재 실행 중인 스레드가 자발적으로 CPU를 양보하여 다른 스레드가 실행될 수 있도록 한다.
  - ```RUNNABLE``` 상태를 유지, 힌트를 줄 뿐, 강제적인 실행 순서를 지정하지 않는다. 


